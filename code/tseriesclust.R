tseriesclust <-
  function(data,maxiter=300,burnin=floor(0.1*maxiter),thinning=2,scale=TRUE,frequency=52,seasonfreq=2,seasondelay=12,
           deg=2,c0eps=2,c1eps=1,c0alpha=2,c1alpha=1,a=2,b=0.5,ab=1,bb=1,ap=1,naux=3,seed=42){
    
    set.seed(seed)
    
    #' tseriesclust performs a persistence-based Bayesian model to cluster time-series using a Dirichlet process as a prior for the parameters of the autoregressive process
    #' 
    #' @param data Data frame with the time series information. 
    #' @param maxiter Maximum number of iterations for Gibbs sampling.Default value = 1000.
    #' @param burnin Burn-in period of the Markov Chain generated by Gibbs sampling.
    #' @param thinning Number that indicates how many Gibbs sampling simulations should be skipped to form the Markov Chain.
    #' @param scale Flag that indicates if the time series data should be scaled to the 0,1 interval. If TRUE, then the time series are scaled to the 0,1 interval. 
    #' @param frequency Number that indicates the frequency of data in a year, e.g. 12 means one value each month.
    #' @param seasonfreq Number that indicates the frequency in a year of season component, e.g. 12 means we consider months as seasonality 
    #' @param seasondelay After how many data begins the first season (useful for example for dividing spring and summer from winter and autumn)
    #' @param deg Degree of the polynomial tendency of the model. Default value = 2. 
    #' @param c0eps Shape parameter of the hyper-prior distribution on sig2eps. Default value = 2.
    #' @param c1eps Rate parameter of the hyper-prior distribution on sig2eps. Default value = 1.
    #' @param c0alpha Shape parameter of the hyper-prior distribution on sig2alpha. Default value = 2.
    #' @param c1alpha Rate parameter of the hyper-prior distributionon sig2alpha. Default value = 1.
    #' @param a Shape parameter of the hyper-prior distribution on sig2the. Default value = 0.5.
    #' @param b Rate parameter of the hyper-prior distribution on sig2the. Default value = 2.
    #' @param ab Shape parameter of the hyper-prior distribution on rho. Default value = 1.
    #' @param bb Rate parameter of the hyper-prior distribution on rho. Default value = 1.
    #' @param ap Parameter of the Dirichlet process. Default value = 1.
    #' @param naux Number of auxiliary variables. Default value = 3.
    
    # OUT:
    # sig2epssample   <- Matrix that in its columns contains the sample of each sig2eps_i's posterior distribution after Gibbs sampling.
    # sig2alphasample <- Matrix that in its columns contains the sample of each sig2alpha_i's posterior distribution after Gibbs sampling.
    # sig2thesample   <- Vector that contains the sample of sig2the's posterior distribution after Gibbs sampling. 
    # rhosample       <- Vector that contains the sample of rho's posterior distribution after Gibbs sampling.
    # msample         <- Vector that contains the sample of the number of groups at each Gibbs sampling iteration.
    # memorygn        <- CL*n matrix where [k,i]=[k,j] if i and j belong to the same cluster at iteration k
    
    
    ##### CONSTRUCTION OF THE DESIGN MATRICES #####
    
    data <- scaleandperiods(data,scale)   # Matrix with the scaled data.
    mydata <- as.matrix(data$mydata)      # Array with the data periods.
    periods <- data$periods               # Variable that indicates if any time series
    cts <- data$cts                       # were removed from the original data set because they were constant.
    
    T <- nrow(mydata)                        # Number of periods of the time series
    n <- ncol(mydata)                        # Number of time series present in the data
    #Construction of the design matrix Z of the linear model, where we take into account the seasonality of the data
    #and the degree of the polynomial trend
    DM <- designmatrices(deg,T,frequency,seasonfreq,seasondelay)      # Construction of the design matrix
    p <- DM$p
    d <- DM$d
    Z <- DM$Z
    
    
    ##### INITIAL VALUES FOR THE PARAMETERS THAT WILL BE PART OF THE GIBBS SAMPLING #####
    
    sig2eps <- matrix(0.0001,n,1)                   
    rho <- matrix(0,n,1)
    sig2the <- 1/(rgamma(n,a,b))
    
    sig2alpha <- matrix(1,p,1)                      # Vector that has the diagonal entries of the variance-covariance matrix for alpha.
    sigmaalpha <- diag(c(sig2alpha),p,p)            # Variance-covariance matrix for alpha.
    invsigmaalpha <- diag(1/c(sig2alpha),p,p)       # Inverse variance-covariance matrix for alpha.
    
    gamma <- rbind(t(rho),t(sig2the))
    alpha <- matrix(mvrnorm(n,matrix(0,p,1),sigmaalpha),p,n)
    
    rho <- rbeta(n,ab,bb)       # Initialization of rho from a beta with domain [-1,1]
    
    P <- array(0,dim=c(T,T,n))                      # Initial vectors of matrices P and R.                    
    R <- array(0,dim=c(T,T,n))
    for(i in seq(n)){
      for (j in seq(T)){
        for (k in seq(T)){
          P[j,k,i] <- rho[i]^(abs(j-k))  
          R[j,k,i] <- sig2the[i]*P[j,k,i]
        }
      }
    }
    
    theta <- matrix(0,T,n)
    for(i in seq(n)){
      theta[,i] <- mvrnorm(1,matrix(0,T,1),R[,,i])
    }
    
    
    ##### MEMORY VARIABLES #####
    
    iter <- 0                                    # Counter for each Gibbs sampling iteration.
    iter1 <- 0                                   # Counter for the number of iterations saved during the Gibbs sampling.
    
    if(thinning == 0){
      CL <- floor(maxiter-burnin)
    }else{
      CL <- floor((maxiter-burnin)/thinning)
    }
    
    memorygn <- matrix(0,CL,n)        # Matrix that will save the group number to which each time series belongs in every iteration saved.  
    sig2epssample <- matrix(0,CL,n)   # Matrix that in its columns will contain the sample of each sig2eps_i's posterior distribution after Gibbs sampling.
    sig2thesample <- matrix(0,CL,n)   # Array(0,dim=c(n,1,CL)) # Vector that will contain the sample of sig2the's posterior distribution after Gibbs sampling. 
    rhosample <- matrix(0,CL,n)       # Vector that will contain the sample of rho's posterior distribution after Gibbs sampling.
    msample <- matrix(0,CL,1)         # Vector that will contain the sample of the number of groups at each Gibbs sampling iteration.
    sig2alphasample <- matrix(0,CL,p) # Matrix that in its columns will contain the sample of each sig2alpha_i's posterior distribution after Gibbs sampling.
    jstarsample <- matrix(0,CL,n)
    
    ##### BEGINNING OF GIBBS SAMPLING#####
    
    while(iter < maxiter){
      
      ####### 1) SIMULATION OF ALPHA'S POSTERIOR DISTRIBUTION #####
      
      for(i in 1:n){
        sigmaeps <- diag(c(sig2eps[i]),T)
        Q <- sigmaeps + R[,,i]
        Qinv <- chol2inv(chol(Q))
        
        Valphainv <- (t(Z) %*% Qinv %*% Z) + invsigmaalpha
        Valpha <- chol2inv(chol(Valphainv))
        
        mualpha <- Valpha %*% t(Z) %*% Qinv %*% mydata[,i]
        
        alpha[,i] <- mvrnorm(1,mualpha,Valpha)
      }
      
      
      
      ####### 2) SIMULATION OF THETA'S POSTERIOR DISTRIBUTION #####
      
      for(i in 1:n){
        invsigmaeps <- diag((1/sig2eps[i]),T)
        Rinv <- solve(R[,,i])     
        Sinv <- invsigmaeps + Rinv
        Stheta <- solve(Sinv)   #Stheta <- chol2inv(chol(Sinv))
        mutheta <- Stheta %*% invsigmaeps %*% (mydata[,i] - Z %*% alpha[,i])
        theta[,i] <- mvrnorm(1,mutheta,Stheta)
      }
      
      
      ####### 3) SIMULATION OF GAMMA'S = (rho,sigma) POSTERIOR DISTRIBUTION #####
      
      #Algorithm adapted from the Algorithm 8 of the paper: 'Markov Chain Sampling Methods for Dirichlet Process Mixture Models'(2000) by Radford M. Neal
      
      for(i in 1:n){
        # The entries of gamma[,-i] are compared to determine the cluster configuration
        # comp11 is a function that computes the distinct observations and frequencies in a numeric vector.
        gr <- comp11(gamma[1,-i])                    
        jstar <- gr$jstar                                 # Object that contains the positions of the unique vectors in gamma[,-i]
        mi <- gr$rstar                                    # Number of unique vectors in gamma(-i) (Number of groups)
        h <- mi + naux
        gmi <- gamma[,-i]                                 # Matrix with all the elements of gamma, except for the i-th element
        gammastar <- matrix(0,2,h)
        gammastar[,1:mi] <- as.matrix(gmi[,jstar])        # Matrix with the unique vectors in gamma(-i)
        nstar <- gr$nstar                                 # Frequency of each unique vector in gamma(-i)
        cci <- which(gr$jstar==TRUE)                      # Positions in gamma[,-i] of the unique values appearing for the first time
        
        # we sample naux times the auxiliary variables from P0
        for(iaux in 1:naux){
          gammastar[1,mi+iaux] <- rbeta(1,ab,bb)
          gammastar[2,mi+iaux] <- 1/(rgamma(1,a,b))
        }
        
        # Matrices necessary for the following steps
        sigmaeps <- sig2eps[i]*diag(1,T)
        invsigmaeps <- diag((1/sig2eps[i]),T)
        
        q <- as.vector(matrix(0,h,1))
        
        for(iaux in 1:mi){
          
          Rinv <- solve(R[,,cci[iaux]])     
          Sinv <- invsigmaeps + Rinv
          Stheta <- solve(Sinv)   #Stheta <- chol2inv(chol(Sinv))
          mutheta <- Stheta %*% invsigmaeps %*% (mydata[,i] - Z %*% alpha[,i])
          Fthei <- dmvnorm(theta[,i], mean = mutheta, sigma = Stheta)
          
          q[iaux] <- nstar[iaux]*Fthei/(n-1+ap)               
        }
        
        if(!(gamma[1,i] %in% gammastar[1,])){          # if the value gamma_i is not present in teh unique values of gamma_-i, we add as a auxiliary variable
          gammastar[,mi+1]=gamma[,i]
        }
        rhostar <- as.matrix(gammastar[1,])
        sigma2star <- as.matrix(gammastar[2,])
        
        for(iaux in (mi+1):h){
          Raux <- matrix(0,T,T)
          for (j_a in seq(T)){
            for (k_a in seq(T)){
              Raux[j_a,k_a] <- sigma2star[iaux]*rhostar[iaux]^(abs(j_a-k_a))  
            }
          }
          
          Rinv <- solve(Raux)     
          Sinv <- invsigmaeps + Rinv
          Stheta <- solve(Sinv)   #Stheta <- chol2inv(chol(Sinv))
          mutheta <- Stheta %*% invsigmaeps %*% (mydata[,i] - Z %*% alpha[,i])
          
          Fthei <- dmvnorm(theta[,i], mean = mutheta, sigma = Stheta)
          
          q[iaux] <- (ap/naux)*Fthei/(n-1+ap)
        }
        if(sum(is.na(q))>0){q[which(is.na(q))]=0}
        if(sum(q)!=0) {
          q <- q/sum(q)
          
          # Sampling a number between 1 and h to determine what will be the simulated value for gamma(i)
          # The probabilities of the sample are based on the weights previously computed
          
          c_i <- sample(1:h, size=1, prob = q)
          gamma[,i] = gammastar[,c_i]
          
        }  else{
          i=i-1
        }
        
      }
      
      rho <- gamma[1,]
      sig2the <- gamma[2,]
      
      
      ####### 4) LABEL ASSIGNMENT #####
      # Computation of all latent classes of the gamma vectors after the simulation of their posterior distribution.
      # comp11 is a function that computes the distinct observations and frequencies in a numeric vector.
      gr <- comp11(gamma[1,],iter,maxiter)                   
      jstar <- gr$jstar
      gammastar <- as.matrix(gamma[,jstar])     # Unique values of the gamma vectors. 
      m <- gr$rstar                             # Total number of latent classes (groups).
      nstar <- gr$nstar                         # Frequency of each latent class (group).
      gn <- gr$gn                               # Identifier of the group to which each time series belongs.
      cci <- which(gr$jstar==TRUE)              # Positions in gamma[,-i] of the unique values appearing for the first time
      
      for(i in 1:m){
        gamma[1,which(gn==i)] <- gamma[1,cci[i]]
        gamma[2,which(gn==i)] <- gamma[2,cci[i]]
      }
      rho <- gamma[1,]
      sig2the <- gamma[2,]
      
      ####### 5) SIMULATION OF SIG2EPS' POSTERIOR DISTRIBUTION #####
      
      M <- t(mydata - Z%*%alpha - theta) %*% (mydata - Z%*%alpha - theta)
      sig2eps <- 1/rgamma(n,(c0eps + T/2),(c1eps + diag(M)/2))
      
      ####### 6) SIMULATION OF SIMGAALPHA'S POSTERIOR DISTRIBUTION #####
      
      sig2alpha <- 1/rgamma(p,(c0alpha + n/2),(c1alpha + rowSums(alpha^2)))
      sigmaalpha <- diag(c(sig2alpha),p,p)
      invsigmaalpha <- diag(1/c(sig2alpha),p,p)
      
      
      ####### 7) FINAL STEPS #####
      
      if((iter %% thinning) == 0 & iter >= burnin){
        iter1 <- iter1 + 1
        sig2epssample[iter1,] <- sig2eps
        sig2thesample[iter1,] <- sig2the
        rhosample[iter1,] <- rho
        msample[iter1] <- m
        memorygn[iter1,] <- gn
        jstarsample[iter1,] <- jstar
        sig2alphasample[iter1,] <- sig2alpha
      }
      
      iter <- iter + 1
      pb$tick()
    }
    
    ##### END OF GIBBS SAMPLING #####
    
    params = list(data,maxiter=maxiter,burnin=burnin,thinning=thinning,scale=scale,
                  deg=deg,c0eps=c0eps,c1eps=c1eps,c0alpha=c0alpha,c1alpha=c1alpha,
                  a=a,b=b,ab=ab,bb=bb,ap=ap,
                  naux=naux)
    
    return(list(sig2epssample = sig2epssample, sig2alphasample = sig2alphasample,
                sig2thesample = sig2thesample, rhosample = rhosample, msample = msample,
                memorygn=memorygn, jstarsample=jstarsample, params=params))
    
  }
